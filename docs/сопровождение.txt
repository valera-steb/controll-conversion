как разбить СУ на S и SU, где
  S - система управления, которая сама ОУ
  SU - прикладная концепция - конкретная для данного ОУ.
=> плохие названия, сути не выражают.

+ например, нужен список стереотипов. Этот список, часть
 большего объекта - какого?

 .есть конкретный стереотип, который цепляеться на ОУ в нужной
 ему части и мониторит ситуацию - он часть прикладной концепции

=>
 App - Application - приложение, приложение концепции
    хотелось - прикладная концепция.
 SI - System Infrastructure - инфраструктура концепции

=> Выходит 2 сущности:
 App - описывает прикладную концепцию, при этом:
   .использует архитектуру созданную SI
   .и для работы, прикладной внутренности архитектуры
   не должны быть видны, её UI не нужен.

 SI  - создаёт инфраструктуру, однако:
   .есть желание увидеть её внутренности.
   .UI есть отдельная вещь, о которой App:
     .знать не должен,
     .влияние на себе не испытывать.

.далее:
  .цели и компараторы с ними
  + кто будет заполнять поле ошибки?:
    .компаратор.
    .цфу.
    .вместе.

.цели:
  .каждая цель строиться над каким-либо стереотипом.
  .однако, для компаратора могут потребоваться значения
  разных стереотипов.
  + вопрос о том, стоит ли строить цель над множеством
  стереотипов.

  .целепологание происходит относительно фактора.
  .однако, фактор может быть оценен разными стереотипами.
  .и тогда над каждый стереотипом встанет своя цель.
  =>? деффективность ли это (вектора целей),
    .ведь один фактор порождает несколько целей
    в зависимоти от восприятия.

.текущая статистика:
  .9 файлов прикладной концепции.
  .6 файлов инфраструктуры.
  .4 файла ОУ (в которых ранее умещалось управление).
+ прогноз:
  .+3 (12) файлов прикладной концепции.
  .~2 (8)  файлов инфраструктуры.
  .+0 (4)  файла ОУ.

.решение:
  .пока все параметры состояния считаю контрольными
  т.е. изменение любого ставит задачу на выработку
  управляющего воздействия.

.далее:
  .StateController и FunctionLauncher.
  .а потом ControlImpactApplier.

+ далее:
  .написать пару цфу:
    .отобразить.
    .прикрепить к целям.
    + подсветка активной.
  .добавить в FunctionLauncher запуск цфу.
  .заняться ControlImpactApplier-ом.

--------------------
.следующая итерация
  .усложнения (задача_01):
    .добавить UI сервера.
      .кнопка ответа на запрос.
      .кнопка на подтверждение отмены запроса.
      .кнопка блокировки сервера.

    .добавить в UI клиента кнопку отмены.

    .подрисовать оформление.

  + следующий шаг - модификация су:
    .ПФУ на кнопку отмены.

    .ПФУ на падение сервера.
    + модификация ОУ.

.как должна выглядеть нативная реализация?
  .с учётом перехода в режим пингования?
  .какие есть ответственности и как они разпределяються?

  .добавить пингера, который будет использовать Requester-а,
  активироваться по сбою в запросе (Requester-ом)
  UI отслеживать его состояние и сообщение отображать

  .стоит ли усложнять модель, либо отсеч на уровне UI?
  (я про работу пингера, и что когда он активен
   запросы не пропускаем)

.пожелание:
  .индекс в корне - должен работать на нативной реализации с подгрузкой СУ в режиме наблюдателя.
  .индекс в concept - работать на СУ, без нативной реализации.

.конфликт:
  .модель_сервера - не есть частью ОУ.
  .но часть чего она?
  .в ОУ нужен интерфейс к моделе_сервера.
  .а сама модель - необходимое условие для работы. Вообще, она часть среды.
  !!!ключевой вопрос - кто за неё отвечает?
    .либо иная трактовка - как за неё отвечает СУ?
    .и тут-же: а каков вообще его уровень ответственности, и кто кроме него существует?
      .ведь есть ещё процесс инициализации, которым СУ не управляет.
  .т.е. за модель_сервера отвечает "инициализатор", и к моменту введения СУ в игру, модель уже есть.

.соображения по модели сервера (с его контекстом):
  .данная модель предоставила:
    .интерфейс ОУ.
    .интерфейм вивМодели _модели_сервера_.
    .внутреннюю логику, поведение для взаимного согласования:
      .обоих интерфейсов.
      .состояния модели.
  .интерес тут как раз в этом согласовании.
  модель выходит субъектом, управляющим/влияющим на обе стороны
  + взаимный учёт интересов...

.текущая задача:
  .втроить модель сервера.
  .и связать её с вивМоделью.

+ зачем мне граф состояний Requester-a?
  .все-ли состояния в нём нужны?
    .loaded и canceled - есть ли что-то заставляющее их различать?
    + учитывая наличие oldState, я их могу различить.
  + как отличить ситуацию?:
    .загрузка-отмена-подтвердили отмену: canceling->done.
    .загрузка-отмена-результат запроса: canceling->done.

  .как-бы происходит повторение функционала по проверки одного запроса.
  => хотя никто не отменял ошибок в коде.
=>:
  .эти состояния есть? - да.
  .в этих состояниях вызовы ведут себя по разному? - да.
  .состояние кто-то отслеживает, оно как-то отображаеться? - да.
    .отслеживает вив, который показывает соответствующую картинку:
      .loading... с кнопкой отмена.
      .canceling...
+ а как насчёт отмены отмены?
  .дргими словами, сервер отказался отменять выполняемый запрос.

.факторы Requester-a:
  .есть граф переходов, на каждом переходе свой метод.
  .кроме этих методов,
!нужно детальнее изучить последовательность вызовов промайсов когда есть отмена.

.а не получаеться ли так, что ServerModel оказываеться лишним внутри функционалом?
  .ведь any, done, fail - можно прокинуть и самому,
  напрямую от виваСервера?
  .ServerModel даёт:
    .эмуляцию get и cancel, с валидацией этих действий.
    .хранит запрошенный урл.
    .прокидывает связки ответов.
  .предположим get и cancel можно самому зделать, хотя - их эмуляция не входит:
    .ни в ответственность виваСервера.
    .ни в ответственность Requester-а.
  .requestedUrl можно хранить:
    .в вивМоделе - однако это нарушение доступа - модель будет знать о вивМодели.
    .в отдельном объекте - но объект должен отслеживать сообщения между моделью
    и вивМоделью.
  .связки прокинуть напрямую, но
    .нарушение доступа.
    .не обязанность вивМодели.
+ можно ли упростить, что-либо выкинуть из ServerModel?
  .думаю нет, этот функционал тесно связан между собой.

.как-бы сделать простую проверку доступности переходов?
  .actions: {get:f, set:f}.
  .call(graph.actions.get)


.Tasker:
  .что о нём нужно знать?
    .в процессе/нет.
    .длинну очереди.
    .момент, когда полностью закончил работать.
  .а что сейчас я от него хочу, в минимуме?
    .выстраивать очередь.
    .вызывать из очереди по завершению.

.и что дальше?
  .уже есть:
    .инфраструктура под граф - в приемлемом виде и необходимой функциональностью.
  .т.е. дальше:
    .надо вспомнить что я делал до неё.
    .где и зачем мне понадобился автомат на графе.

  .и так:
    .я делал Requester.
    .нарисовал под него граф.
    .задумался о его реализации.

  .вывод очевиден )

+ пожелания:
  .при ошибке валидации метода желательно указать детали:
    .метод, состояния текущее/следующее, имя метода валидации.

  .проверить доступность ошибок:
    .от таскера - он глобальный / приходит из вне - там разберуться.
    .DelegatesMap.
    .FsmSubscription - в основном проверка параметров.

.Requester:
  .есть ли какие-то обязательные параметры у событий?
  (наличие которых стоит проверять):
    .гет должен содержать урл.
    .эни может содержать данные.

  .не сходиться с моделью сервера.
    .server.getDeferred().resolveWith('data'):
      .в начале вызывает requester.actions.any.
      .потом requester.actions.fail.
    .а хотелось бы в обратном порядке.
    => отдельную функцию, на приём данных.

    .у canceling нет перехода по any - а это событие происходит.
  => задача:
    .спрятать getDeferred, но что вместо него?
      .sendData - с параметром для данных.
      .либо 2 метода с верху.
      .либо так-же деферред, только построенный чуть длиннее.
      .т.е. встроить деферред.


и так, реквестер работает ожидаемо, что дальше?
  .встроить реквестер в нативную реализацию.
  .подцепить к виву.
  .подцепить к текущему UrlController-у.

.реализация:
  .вернуться к вмСерверМодели.
  .

.далее:
  .довыносить нативную реализацию.
  .подумать что ещё нужно добавить в текущий функционал.
  + может его как-то описать?
  ++ например в виде спецификации исполняемой?
  .подумать над уточнением UrlController-а.


исполняемая спицификация:
  .нужно оценить:
    .её полезность.
    .удовлетворительность дописанной библиотеки.

  .выявить подход:
    .как писать эту спецификацию?
    .что делать?
    .как соотносится с ПФУ?

.пока интересно:
  .дописал тест на переотправку урл.

.но теперь концептуальный вопрос
!!! кто должен отработать ошибку запроса?
  .т.е. чья ответственность зафиксировать ошибку и на неё отреагировать?
  .варианты:
    .логика ОУ.
    .управляющая часть (native/SU).
=>
  .думаю управляющая часть, т.к.
    .это проброс взаимодействия между разными частями ОУ.
    .но почему тогда я спокойно подписываю вм на события из модели?
      .суть вм - отражать текущее состояние модели.
    .ОУ должен уметь выполнять команды от СУ, при этом
      .команда однозначна, пускай и с параметрами.
    .отлов остояния - введен урл - есть фактор,
    реакция на который не однозначна. Т.е. решение должен принять СУ.

+ теперь вопрос про vm/ou - не всё в ней простое отображение состояния.
  .например есть m.requester.actions.cancel().

.вопрос по спецификации:
  .программно я могу дотянуться до вещей, в интерфейсе на данный момент не видных
  стоит ли их тестировать?
  .это приведёт к созданию проверок более жёстких.
  .но какова польза от этого?

.к концепции:
  .в вивМодель ли переносить проброс вызова - по идее она должна только
  подписку зделать, а уж выбор - на модели висит.

.ещё одно но:
  .урл должен быть где-то в другом месте, поскольку его из модели
  задавать надо.
  .и вот вопрос - стоит ли ОУ иметь доступ к структуре вивМоделей?
  .но, если его вынести в модель... кандидатов 2:
    .базовый объект.
    .UrlController.
  .в обоих случаях, встаёт вопрос, почему это нельзя обработать в ОУ?
    .зачем его вытягивать в отдельный класс?
    + тут я вспоминаю вопросы - зачем использовать ООП?
    .т.е. я провожу ещё одну линию разграничения, ввожу уровень понятий
    и тут это... деление на ОУ и СУ, со своими ответственностями.
    а в рамках ответственностей СУ - принятие решения о действиях,
      управленческого решения.

    .с этой точки зрения:
      .Server - воплощает закономерности объекта.
      .Requester - тоже закономерности, только собранные в состояния и со
      своими ограничениями
      .UrlController - его метод setUrl, который обращаеться к Requester...
      несколько странным кажеться.
      да и тогда, подписка его на прослушку событий....

    .другими словами:
      .каждый из "валидных" объектов:
        .предоставлял состояние.
        .и методы его изменения - но:
          .Requester пробрасывает вызов серверу
          .и прослушивает его ответ...

    .какой фактор я стараюсь разпознать?
      .разность между:
        .закономерностью объекта.
        .управляющим воздействием субъекта.
      .почему:
        .взаимодействие Requester-а и Server-а есть частью ОУ.
        .взаимодействия UrlController-a и Requester-a я не воспринимаю частью ОУ.
        .условие загрузки - тоже не часть ОУ.
      ?

    .по идее, субъект и концепция.
    .средства - способы - методы - ресурсы - конфигурация - разпределение
     - настройка - эмоции - воля - контакт - степень/объём - внимание
     - ограничения - режимы - причина/фактор - результат - сопровождение.

    .однонаправленность/одновариантность - являються ли причиной выделения
    оставляния чего-то в ОУ? - нет.

    .причнина/фактор деления на СУ и ОУ:
      .есть закономерности - отражённые, проростающие из среды.
      .есть цель и концепция её достижения, в частности - описание способа.
      .структура среды?

    .а как насчёт "длинны связи" команды.
    .кстати - стереотип - разпознаёт ситуацию.
    .а ещё:
      .введение понятия стереотип разграничивает ОУ и СУ, ведь ОУ не различает?
      .без этого понятия, не различимо кое-что для программистов.
    .другими словами:
      .различение ситуации, её оценка, соотнесение с понятийной базой СУ
       - это уровень СУ, и следствия этого соотнесения - управляющие решения
       есть компетенция СУ, а точнее алгоритмы, по которым он их принимает.
       + возможна и вложенность - процесс исполнения алгоритма
       выработки управленческого решения есть ОУ, но есть и СУ
        .его запустившие - кто применет это решение.
        .им управляющие - кто контролирует процесс выработки.

      .отражение закономерностей, как система восприятия есть частью ОУ
        его воспринимающей частью?

    .процесс отображения и перемещение.
    а также - какими процессами управлять?
      а на какие полагаться? - в смысле ими управляют другие,
        но "я" на базе этих процессов строю свою деятельность/управление.

    .однозначно ли выявление процессов?
      .равно как - однозначно ли разграничение процессов?

    + что я понимаю под процессом?
      .меру-матрицу - она объективна и... где грани?
      .материю в процессе учавствующую - она количественно измерима
       с поправкой на точность измерений.
      .информацию - тут что и как?

    .что есть суть процессов отражения и перемешения?
      .может концепция?
    .и чем СУ программный будет управлять?
      .а чем он может управлять?

.принципиальная разница видов управления:
  ."непосредственное" - думаю коррелируеться с понятием структурного управления -
  в основном я его вижу как управление разпространением информации по сформированной
  структуре. Процесс устоявшегося управления разбит на 2 этапа:
    .снятие состояния.
    .по состоянию принятие решения о том куда какую информацию направить
  Соответственно направление информации - активизация структур которым её направили.

  .матричное - думаю это в точностии соответствует понятию из ДОТУ. Управленческое
  решение тут есть установление связей между структурами, так что-бы они
  самоуправлялись в выбранном направлении - другими словами:
    .информация, протекающая по связям
    .и передача активности между структурами, связями определённая
  направляли течение процесса/процессов в заданном русле.

+ отсюда разница в формируемых структурах, точнее требований к ним (структурам):
  .у непосредственного:
    .наблюдаемость необходимых (для принятия решения) состояний/параметров.
    .открытость средст воздействия на структуру/ОУ.
  .у матричного:
    .так-же наблюдаемость состояний - но эти уже менее детальные.
    .возможность влияния на связи внутри ОУ.

.выходит мне нужны несколько вариантов примера с СУ.
  .однако как-же не хочеться ломать довольно хорошо собранное взаимодействие
  Server-a и Requester-a.

  .что-же делать?

+ я ещё не закончил выяснение наличиствующих процессов.
  .да и про чувство меры вопрос открыт.

.мои пожелания:
  .почему-то я хочу с минимальными усилиями довести проэкт до конца.
  .пологаю перестройка понятий запущена с последним шагом
  и что делать, пока она завершиться?
.есть отступ, который вроде можно принять:
  .не всеми процессами надо управлять, ведь выше уже было сказанно,
  что на часть можно положиться.
  .вопрос выбора:
    .чем управлять,
    .а что реализовывать внутренней логикой ОУ?
  .раз перенос всего признан излишним и вообще-то невозможным...
  .хотя, возможно вопрос можно задач иначе:
    .что оставить на уровне матричного управления
    .а что перенести в дерективно-адресное
  + при этом предпологаеться, что матрица не будет менться
  дабы не разрушить дерективно адресное.

  .пологаю так-же, в дерективно-адресном, оставленный кусочек матричного
  будет напоминать, что него (1-го) есть вполне обозримые ограничения.
  .т.е. сейчас зделан вывод, что матричное намного шире
  а другими словами - тем-же небольшим ресурсом и со знанием матриц
  можно управлять намного большим набором процессов, более сложным ОУ.
  .хотя, возможно правильнее было-бы сказать -
  перенастраивать самоуправление ОУ.

  .тогда, вопрос меняеться:
    .какие части могут перенастраиваться,
    .какие средства/части_ОУ должны быть открыты для перенастройки.

.а ещё, последнюю постановку стои соотнести с идеей подхода, ранее разсмотренной.
  .там где было про части наброски, их появление и сборку.
  .вот только найти не могу....
    .было про прототипирование начальное.
      про стремление выделить общее/частное
      и разбираться в начале с повозможности наиболее общим
  .другими словами, идею вижу как:
    .выделение кусочков/модулей можно соотнести с выделением самоуправляемых
    частей ОУ.
    .потом над ними нужно будет выстраивать управление их согласующее.


дописываю функциональные тесты:
.:
  .чему я хотел научиться с ними?
  .где и когда я могу их писать?
  .на чём они основываються?
  .как их писать - в Gherkin виде?
  .BDD - behavior-driven development - разработка направляемая поведением?


хостинг:
.всё-же пора, хотел Анне Минаевой показать, может найдёт какие ошибки.
=> захостил на http://tinhost.ru/ - пока не понятно почему напрямую домен не подключаеться - жду обновления днс.


итого: есть тесты и нативная реализация.
что дальше?:
.добавить установку режима, и само понятие режима.
.а есть ли тесты на формируемую библиотеку,
+ могу-ли я её дизайн уже увидеть/оценить?
.выделить код библиотеки... в отдельную сборку.

.реализация альтернативная.
.тесты в двух режимах запуска...

+ оказываеться:
  .тестов под SI часть у меня нету....
  .и какие функции есть у неё?

и далее, надо разписать детали для каждой функции.
.основываясь на уже набросанных комментариях в подумать.
.и существующей реализации - ведь её перестраивать буду / по ней писать.



итого:
.набросал стереотипов.
.набросал тестовый оу.
.умею стереотипы подгружать.
.набросок конфига концепции.

надо:
.цели описать:
  .в цели параметром попадает имя стереотипа.
  .а внутри должен быть некий компаратор.
  .цель невалидная, если её компаратор выдал что-то истинное: true/{...}
+ соответственно в вектор ошибки падает вот выданный компаратором объект.
.функций добавить.
.режим начальный описать.

.загрузчики для каждого добавить.



тест компаратора
testConcept.state.s1 = testConcept.stereotypes.map.s1.create(testConcept, testModel);
testConcept.state.s4 = testConcept.stereotypes.map.s4.create(testConcept, testModel);
var comparator = testConcept.stereotypes.map.c1.create(testConcept);



итого:
.добавил тест для создания компаратора.
.тесты для инфраструктуры можно и нужно писать.
.переправил стереотип и список стереотипов под конфигурацию.

длее:
.докрыть тестами создание компаратора:
  .ситуация, когда в состоянии не хватает стереотипа.

.процедура загрузки функции/компаратора.
.а над ней - процедура смены режима.


восстановить ход мыслей и продолжить написание кода:
.закончил на выходе в переосмысление таблицы:
  .понятия цели, стереотипов, их взаимосвязей.
+ тесты и задача о подгузке/выгрузке стереотипов по функциям, компараторам
  .а функций, целей и компараторов по режиму.
+ выходит есть определённая процедура установки режима:
  .вытянуть функции, цели, компараторы - поместить в промежуточное хранилище.
  .по выше - выявить набор стереотипов и создать их.
  .создать функции, цели, компараторы.
  .подгрузить структуру в матрицу.


ситуация:
.таки наткнулся на вариант, когда внешнее возмущение ещё не применилось
  но уже выполняеться выбор управления,
  поскольку стереотип зафиксировал изменение
  а comparatorsWatcher зафиксировал необходимость что-то поменять
  и дальше по цепочке...

.когда проводить цикл управления?
  .когда:
    .закончатся изменения.
    .выявиться необходимость что-то зделать.
    .

  .варианты:
    .отлавливать первый...
    .есть событие - до обновления, и собственно само обновление.
      .если подписаться на само обновление после события...

+ сценарии:
  .сразу по изменению.
  .с задержкой, от первого запроса.

.тогда ограничения:
  .1 - функции должны учитывать, что может быть циклическое изменение.
    .его как-то разорвать надо... либо хотя-бы отследить.
    ! кажеться ко это умеет делать.

  .2 - нужно прописать приоритетность переходов?
    .это о чём я?
    .если пришло несколько запросов...


между чем делать пробелы?
.преходы:
  .компаратор - выбор функции - вычисление - выполнение.
.думаю на:
  .watching -> calculating.
  .applying -> calculating.

.как их отловить?
  .кроме перехвата вызовов, и проверки в каком состоянии исполнитель.
  .и от этого выбор - либо граф вызвать, либо отложенное действие запланировать.


текущие задачи:
.обновить тесты, с учётом разрыва переходов.
.поправить вызовы...
.вернуться к тестам вписывания исполнителя.

+ кстати:
  .наборы тестов и фикстур для обоих режимов надо бы добавить:
    .с разрывом который.
    .и без.
  .возможно даже с наложением разных:
    .у одного есть у другого нет.
    .ведь они есть в:
      .графе исполнителя.
      .в функции ControlImpactApplier-а.

итого:
.есть тесты - был только 1.
.собрал Delayer и добавил ему тестов на режим с задержкой.
.подключил Delayer в исполнитель - надо проверить что корректность.
!! в функциональном тестировании можно зделать пункт - задержка на такое-то время.

+ далее:
.тесты для исполнителя... как он сейчас работает и как должен?




итого:
.поиски ди для js.
.ознакомился с wire https://github.com/cujojs/wire/tree/master/docs
.ещё надо запустить с require.js и посмотреть как происходит оптимизация.
.и добавить в инфраструктуру библиотеки - для browsered-jasmine-cucumber.
.разобрать git submodule - как добавить в свой проэкт?

+:
  .подмодули гита.





добавил хостинг на http://cpanel.1freehosting.com/


















