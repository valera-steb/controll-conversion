как разбить СУ на S и SU, где
  S - система управления, которая сама ОУ
  SU - прикладная концепция - конкретная для данного ОУ.
=> плохие названия, сути не выражают.

+ например, нужен список стереотипов. Этот список, часть
 большего объекта - какого?

 .есть конкретный стереотип, который цепляеться на ОУ в нужной
 ему части и мониторит ситуацию - он часть прикладной концепции

=>
 App - Application - приложение, приложение концепции
    хотелось - прикладная концепция.
 SI - System Infrastructure - инфраструктура концепции

=> Выходит 2 сущности:
 App - описывает прикладную концепцию, при этом:
   .использует архитектуру созданную SI
   .и для работы, прикладной внутренности архитектуры
   не должны быть видны, её UI не нужен.

 SI  - создаёт инфраструктуру, однако:
   .есть желание увидеть её внутренности.
   .UI есть отдельная вещь, о которой App:
     .знать не должен,
     .влияние на себе не испытывать.

.далее:
  .цели и компараторы с ними
  + кто будет заполнять поле ошибки?:
    .компаратор.
    .цфу.
    .вместе.

.цели:
  .каждая цель строиться над каким-либо стереотипом.
  .однако, для компаратора могут потребоваться значения
  разных стереотипов.
  + вопрос о том, стоит ли строить цель над множеством
  стереотипов.

  .целепологание происходит относительно фактора.
  .однако, фактор может быть оценен разными стереотипами.
  .и тогда над каждый стереотипом встанет своя цель.
  =>? деффективность ли это (вектора целей),
    .ведь один фактор порождает несколько целей
    в зависимоти от восприятия.

.текущая статистика:
  .9 файлов прикладной концепции.
  .6 файлов инфраструктуры.
  .4 файла ОУ (в которых ранее умещалось управление).
+ прогноз:
  .+3 (12) файлов прикладной концепции.
  .~2 (8)  файлов инфраструктуры.
  .+0 (4)  файла ОУ.

.решение:
  .пока все параметры состояния считаю контрольными
  т.е. изменение любого ставит задачу на выработку
  управляющего воздействия.

.далее:
  .StateController и FunctionLauncher.
  .а потом ControlImpactApplier.

+ далее:
  .написать пару цфу:
    .отобразить.
    .прикрепить к целям.
    + подсветка активной.
  .добавить в FunctionLauncher запуск цфу.
  .заняться ControlImpactApplier-ом.

--------------------
.следующая итерация
  .усложнения (задача_01):
    .добавить UI сервера.
      .кнопка ответа на запрос.
      .кнопка на подтверждение отмены запроса.
      .кнопка блокировки сервера.

    .добавить в UI клиента кнопку отмены.

    .подрисовать оформление.

  + следующий шаг - модификация су:
    .ПФУ на кнопку отмены.

    .ПФУ на падение сервера.
    + модификация ОУ.

.как должна выглядеть нативная реализация?
  .с учётом перехода в режим пингования?
  .какие есть ответственности и как они разпределяються?

  .добавить пингера, который будет использовать Requester-а,
  активироваться по сбою в запросе (Requester-ом)
  UI отслеживать его состояние и сообщение отображать

  .стоит ли усложнять модель, либо отсеч на уровне UI?
  (я про работу пингера, и что когда он активен
   запросы не пропускаем)

.пожелание:
  .индекс в корне - должен работать на нативной реализации с подгрузкой СУ в режиме наблюдателя.
  .индекс в concept - работать на СУ, без нативной реализации.

.конфликт:
  .модель_сервера - не есть частью ОУ.
  .но часть чего она?
  .в ОУ нужен интерфейс к моделе_сервера.
  .а сама модель - необходимое условие для работы. Вообще, она часть среды.
  !!!ключевой вопрос - кто за неё отвечает?
    .либо иная трактовка - как за неё отвечает СУ?
    .и тут-же: а каков вообще его уровень ответственности, и кто кроме него существует?
      .ведь есть ещё процесс инициализации, которым СУ не управляет.
  .т.е. за модель_сервера отвечает "инициализатор", и к моменту введения СУ в игру, модель уже есть.

.соображения по модели сервера (с его контекстом):
  .данная модель предоставила:
    .интерфейс ОУ.
    .интерфейм вивМодели _модели_сервера_.
    .внутреннюю логику, поведение для взаимного согласования:
      .обоих интерфейсов.
      .состояния модели.
  .интерес тут как раз в этом согласовании.
  модель выходит субъектом, управляющим/влияющим на обе стороны
  + взаимный учёт интересов...

.текущая задача:
  .втроить модель сервера.
  .и связать её с вивМоделью.

+ зачем мне граф состояний Requester-a?
  .все-ли состояния в нём нужны?
    .loaded и canceled - есть ли что-то заставляющее их различать?
    + учитывая наличие oldState, я их могу различить.
  + как отличить ситуацию?:
    .загрузка-отмена-подтвердили отмену: canceling->done.
    .загрузка-отмена-результат запроса: canceling->done.

  .как-бы происходит повторение функционала по проверки одного запроса.
  => хотя никто не отменял ошибок в коде.
=>:
  .эти состояния есть? - да.
  .в этих состояниях вызовы ведут себя по разному? - да.
  .состояние кто-то отслеживает, оно как-то отображаеться? - да.
    .отслеживает вив, который показывает соответствующую картинку:
      .loading... с кнопкой отмена.
      .canceling...
+ а как насчёт отмены отмены?
  .дргими словами, сервер отказался отменять выполняемый запрос.

.факторы Requester-a:
  .есть граф переходов, на каждом переходе свой метод.
  .кроме этих методов,
!нужно детальнее изучить последовательность вызовов промайсов когда есть отмена.

.а не получаеться ли так, что ServerModel оказываеться лишним внутри функционалом?
  .ведь any, done, fail - можно прокинуть и самому,
  напрямую от виваСервера?
  .ServerModel даёт:
    .эмуляцию get и cancel, с валидацией этих действий.
    .хранит запрошенный урл.
    .прокидывает связки ответов.
  .предположим get и cancel можно самому зделать, хотя - их эмуляция не входит:
    .ни в ответственность виваСервера.
    .ни в ответственность Requester-а.
  .requestedUrl можно хранить:
    .в вивМоделе - однако это нарушение доступа - модель будет знать о вивМодели.
    .в отдельном объекте - но объект должен отслеживать сообщения между моделью
    и вивМоделью.
  .связки прокинуть напрямую, но
    .нарушение доступа.
    .не обязанность вивМодели.
+ можно ли упростить, что-либо выкинуть из ServerModel?
  .думаю нет, этот функционал тесно связан между собой.

.как-бы сделать простую проверку доступности переходов?
  .actions: {get:f, set:f}.
  .call(graph.actions.get)


.Tasker:
  .что о нём нужно знать?
    .в процессе/нет.
    .длинну очереди.
    .момент, когда полностью закончил работать.
  .а что сейчас я от него хочу, в минимуме?
    .выстраивать очередь.
    .вызывать из очереди по завершению.

.и что дальше?
  .уже есть:
    .инфраструктура под граф - в приемлемом виде и необходимой функциональностью.
  .т.е. дальше:
    .надо вспомнить что я делал до неё.
    .где и зачем мне понадобился автомат на графе.

  .и так:
    .я делал Requester.
    .нарисовал под него граф.
    .задумался о его реализации.

  .вывод очевиден )

+ пожелания:
  .при ошибке валидации метода желательно указать детали:
    .метод, состояния текущее/следующее, имя метода валидации.

  .проверить доступность ошибок:
    .от таскера - он глобальный / приходит из вне - там разберуться.
    .DelegatesMap.
    .FsmSubscription - в основном проверка параметров.

.Requester:
  .есть ли какие-то обязательные параметры у событий?
  (наличие которых стоит проверять):
    .гет должен содержать урл.
    .эни может содержать данные.

  .не сходиться с моделью сервера.
    .server.getDeferred().resolveWith('data'):
      .в начале вызывает requester.actions.any.
      .потом requester.actions.fail.
    .а хотелось бы в обратном порядке.
    => отдельную функцию, на приём данных.

    .у canceling нет перехода по any - а это событие происходит.
  => задача:
    .спрятать getDeferred, но что вместо него?
      .sendData - с параметром для данных.
      .либо 2 метода с верху.
      .либо так-же деферред, только построенный чуть длиннее.
      .т.е. встроить деферред.


и так, реквестер работает ожидаемо, что дальше?
  .встроить реквестер в нативную реализацию.
  .подцепить к виву.
  .подцепить к текущему UrlController-у.

.реализация:
  .вернуться к вмСерверМодели.
  .

.далее:
  .довыносить нативную реализацию.
  .подумать что ещё нужно добавить в текущий функционал.
  + может его как-то описать?
  ++ например в виде спецификации исполняемой?
  .подумать над уточнением UrlController-а.