работы с графами.
и так нужны:
  .базовый класс - по входным данным строит вызовы.
    .входные данные: состояния, события, валидаторы, переходы.
      .в переходах, первое состояние - стартовое, на него сброс происходит.
  .подписка - на переход, вход, выход.
  .контроллер вызовов.
    .в минимальной реализации следит, что-бы при вызове события
    во время обработки события оно запускалось после выхода из текущего
    события.

по частям:
		{
            state: {current:_, pred:_},
            params: {},
            actions: {},
            error: _,
            subscribe: {onEnter, onLeave, onTransit},
            reset: f
		}
.базовый класс:
  .должен обеспечить работу с контроллером.
  .должен заполнить объект actions.
  .action в себе должен:
    .опросить контроллер на предмет очереди:
      .не первый - поставить себя в очередь, выйти.
    .контроллеру сказать что работает.
    .проверить допустимость перехода.
    .вызвать валидатор:
      .при сбое - выставить ошибку, закончить.
    .поменять состояние.
    .контроллеру сказать, что закончил.


  .вызов экшена должен:
    .проверить, что у текущего состояния данное действие допустимо.

    .получить детали текущего состояния.
    .просмотреть методы выходные.
    .если есть наш - вызвать выполнение с его деталями.

  .т.е. нужно знать:
    .имя вызываемого метода.
    .текущее состояние.
    .граф переходов, и уметь его фильтровать.


тестирование:
  .модульное, функциональное, системное, интеграционное.
  .определения и соотношения?

  .разве не функциональность всегда тестируеться?
    .с чьей стороны?
      .интерфеса либо внутренностей.
    .какой размер?
      .метод - объект/модуль - подсистема - целое.
    .что конкретнее:
      .функция объекта.
      .работа объектов в взаимосвязе - интеграция.

+ подход к модификации кода покрытого тестами:
  .в начале определить тест/тесты которые можно уточнить.
  предпологаеться, что после уточнения они перестанут работать.
  и далее я будет индикатор успеха )

.наследование в скрипте:
  .не перекрывать напрямую объекты прототипа, например:
var proto = {x:10};

function c(){return this;};
c.prototype = proto;

var o = new c();
o.x = 20; !!! тут перекрываеться o.x объекта с, но в прототипе х остаёться 10.
