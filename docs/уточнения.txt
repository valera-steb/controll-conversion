работы с графами.
и так нужны:
  .базовый класс - по входным данным строит вызовы.
    .входные данные: состояния, события, валидаторы, переходы.
      .в переходах, первое состояние - стартовое, на него сброс происходит.
  .подписка - на переход, вход, выход.
  .контроллер вызовов.
    .в минимальной реализации следит, что-бы при вызове события
    во время обработки события оно запускалось после выхода из текущего
    события.

по частям:
		{
            state: {current:_, pred:_},
            params: {},
            actions: {},
            error: _,
            subscribe: {onEnter, onLeave, onTransit},
            reset: f
		}
.базовый класс:
  .должен обеспечить работу с контроллером.
  .должен заполнить объект actions.
  .action в себе должен:
    .опросить контроллер на предмет очереди:
      .не первый - поставить себя в очередь, выйти.
    .контроллеру сказать что работает.
    .проверить допустимость перехода.
    .вызвать валидатор:
      .при сбое - выставить ошибку, закончить.
    .поменять состояние.
    .контроллеру сказать, что закончил.


  .вызов экшена должен:
    .проверить, что у текущего состояния данное действие допустимо.

    .получить детали текущего состояния.
    .просмотреть методы выходные.
    .если есть наш - вызвать выполнение с его деталями.

  .т.е. нужно знать:
    .имя вызываемого метода.
    .текущее состояние.
    .граф переходов, и уметь его фильтровать.

+ все-же лог в консоль стоит оставить, но ошибки тоже понядобяться.
+ помимо reset добавить метод revert - в состояние до ошибки возвращает.


тестирование:
  .модульное, функциональное, системное, интеграционное.
  .определения и соотношения?

  .разве не функциональность всегда тестируеться?
    .с чьей стороны?
      .интерфеса либо внутренностей.
    .какой размер?
      .метод - объект/модуль - подсистема - целое.
    .что конкретнее:
      .функция объекта.
      .работа объектов в взаимосвязе - интеграция.

+ подход к модификации кода покрытого тестами:
  .в начале определить тест/тесты которые можно уточнить.
  предпологаеться, что после уточнения они перестанут работать.
  и далее я будет индикатор успеха )

.наследование в скрипте:
  .не перекрывать напрямую объекты прототипа, например:
var proto = {x:10};

function c(){return this;};
c.prototype = proto;

var o = new c();
o.x = 20; !!! тут перекрываеться o.x объекта с, но в прототипе х остаёться 10.


BDD тестирование
.библиотеки:
  .Jasmine-species http://rudylattae.github.io/jasmine-species/docs.html
  .cucumber.js http://transitioning.to/2012/01/cucumber-and-js-getting-started-with-cucumber-js/
  .cucumberjs-browser
  .mimik https://github.com/simoami/mimik
  .yadda https://github.com/acuminous/yadda

.характеристики:
  .cucumber.js - нельзя запускать в браузере.

  .Jasmine-species
    - зависит от стрёмной библиотеки namespacedotjs https://github.com/smith/namespacedotjs
      .пока не понял профита в ней... т.к. приходиться создавать файлы описания классов.
    ? пока не понял как с таблицами параметров действовать

  .cucumberjs-browser
    .переформатирует код для выполнения в браузере.
    + выделенные файлы под описание функциональности
    - интерфейс
    ? нужна node.js

  .mimik
    ? пока не понятно что он в браузер выдаёт

.текущий вывод:
  .попробовать 2 библиотеки поднять: Jasmine-species и cucumberjs-browser.
  .функциональное тестирование оказалось чуть больше:
    .зачастую требует большего - управление браузером со стороны.